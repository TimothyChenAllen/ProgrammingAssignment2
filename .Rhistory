makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
help("<<-")
makeVector(x = c(1,2,3))
v <- makeVector(x = c(1,2,3))
v
cachemean(v)
v <- makeVector(x = rnorm(100000)
)
v
cachemean(v)
cachemean(v)
cachemean(v)$data
cachemean(v)
mx < matrix(rnorm(9),nrow=3)
mx <- matrix(rnorm(9),nrow=3)
mx
solve(mx)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(solve) i <<- solve
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setmean(i)
i
}
cmx <- makeCacheMatrix(rnorm(9))
cmx
cacheSolve(cmx)
cmx <- makeCacheMatrix(rnorm(9), nrow=3)
cmx <- makeCacheMatrix(matrix(rnorm(9), nrow=3)
)
cmx
cacheSolve(cmx)
traceback()
debug(cacheSolve)
cacheSolve(cmx)
cacheSolve(cmx)
rm(list=ls())
cacheSolve(cmx)
## These two functions caclulate and return the inverse of a matrix.
## As this is a time-consuming process, we cache the inverse of
## a matrix when it is calculated, to avoid calculating it more than once.
## We retrieve this cached value once it is calculated, as long
## as the matrix is unchanged.
## makeCacheMatrix: This function allows us to create a new matrix.
## This matrix cand return the cached version of its inverse.
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(solve) i <<- solve
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve: This function returns the inverse of a matrix created
## by makeCacheMatrix.  If the inverse has alread been calculated,
## cacheSolve returns the cached copy to save time.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
}
makeCacheMatrix(matrix(rnorm(9),nrow=9))
cmx <- makeCacheMatrix(matrix(rnorm(9),nrow=9))
cacheSolve(cmx)
cmx <- makeCacheMatrix(matrix(rnorm(9),nrow=3))
cacheSolve(cmx)
cmx
cmx$get
cmx$get()
cacheSolve(cmx)
mx <- cmx$get()
mx
solve(mx)
cacheSolve(cmx)
## These two functions caclulate and return the inverse of a matrix.
## As this is a time-consuming process, we cache the inverse of
## a matrix when it is calculated, to avoid calculating it more than once.
## We retrieve this cached value once it is calculated, as long
## as the matrix is unchanged.
## makeCacheMatrix: This function allows us to create a new matrix.
## This matrix cand return the cached version of its inverse.
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(solve) i <<- solve
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve: This function returns the inverse of a matrix created
## by makeCacheMatrix.  If the inverse has alread been calculated,
## cacheSolve returns the cached copy to save time.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
}
big.mx <- makeCacheMatrix(matrix(rnorm(10000),nrow=100))
big.mx$get()
